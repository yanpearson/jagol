<!doctype html>

<html lang="en">
<head>
	<meta charset="utf-8">

	<title>jagol</title>
	<meta name="description" content="Just Another Game Of Life">
	<meta name="author" content="Yan Pearson">

	<!-- <link rel="stylesheet" href="css/styles.css"> -->
</head>

<body>
	<h1>jagol</h1>
	<canvas id="board" width="500" height="500"></canvas>
	<div id="status"></div>
	<div id="game-controller"></div>
	<script src="jagol.js"></script>
	<script src="patterns.js"></script>
	<script>
		// Game
		const oscillator = patterns.oscillator(47, 47);
		const glider = patterns.glider(0, 10);
		const gosperGliderGun = patterns.gosperGliderGun(0, 0);
		const seed = [].concat(oscillator).concat(glider).concat(gosperGliderGun);
		const gameBoard = jagol.board(50, 50, seed);
		const rulesTable = jagol.createRulesTable();
		const doNextGen = jagol.play(rulesTable);

		const loop = (() => {
			let intervalId;
			let renderAt;
			let renderingSpeed = 0;
			let renderingSpeedResults = [];

			const start = () => {
				store.dispatch(startGame());
				intervalId = setInterval(() => {
					const now = window.performance.now();
					const elapsedTime = renderAt ? now - renderAt : 0;
					const renderingSpeedResult = (1000 / elapsedTime) | 0;

					renderingSpeedResults = renderingSpeedResults.concat(renderingSpeedResult);

					if (renderingSpeedResults.length === 100) {
						renderingSpeed = (renderingSpeedResults.reduce((acc, current) => acc = acc + current) / 100) | 0;
						renderingSpeedResults = [];
					}

					store.dispatch(renderBoard());
					store.dispatch(renderStatus(renderingSpeed));

					renderAt = now;
				}, 0);
			};

			const stop = () => {
				clearInterval(intervalId);
				store.dispatch(stopGame());
			};

			return { start, stop };
		})();

		// Actions
		const startGame = () => ({ id: 'startGame'  });
		const stopGame = () => ({ id: 'stopGame' });
		const renderStatus = renderingSpeed => ({ id: 'renderStatus', renderingSpeed });
		const renderBoard = () => ({ id: 'renderBoard' });

		// Reducers
		const gameController = (state = { isStarted: false }, action) => {
			switch(action.id) {
				case 'startGame':
					return {
						isStarted: true
					};
				case 'stopGame':
					return {
						isStarted: false
					};
				default:
					return state;
			}
		};

		const status = (state = { generation: 0, renderingSpeed: 0 }, action) => {
			switch(action.id) {
				case 'renderStatus':
					return { generation: ++state.generation, renderingSpeed: action.renderingSpeed };
				default:
					return state;
			}
		};

		const board = (state = { board: gameBoard }, action) => {
			switch(action.id) {
				case 'renderBoard':
					const nextGen = doNextGen(state.board);
					return { board: nextGen };
				default:
					return state;
			}
		};

		const game = (state = { }, action) => ({
			gameController: gameController(state.gameController, action),
			status: status(state.status, action),
			board: board(state.board, action)
		});

		// Renderering
		const renderGame = (state, originator) => {

			// Game Controller
			const gameControllerView = (startEnabled, stopEnabled) => `
<button id="start" ${startEnabled ? '' : 'disabled="disabled"'}>Start</button>
<button id="stop" ${stopEnabled ? '' : 'disabled="disabled"'}>Stop</button>`;

			const renderGameController = state => {
				const view = gameControllerView(!state.isStarted, state.isStarted);
				const gc = document.getElementById('game-controller');

				gc.innerHTML = view;

				const start = gc.querySelector('#start');
				start.addEventListener('click', loop.start);

				const stop = gc.querySelector('#stop');
				stop.addEventListener('click', loop.stop);
			};

			// Status
			const statusView = (generation, renderingSpeed) => `
<span>Generation: ${generation}</span>
<span>Rendering Speed: ${renderingSpeed} generations/seconds</span>`;

			const renderStatus = state => {
				const view = statusView(state.generation, state.renderingSpeed);
				const gc = document.getElementById('status');

				gc.innerHTML = view;
			};

			// Board
			const renderBoard = state => {
				const drawBoard = (ctx, width, height, cellSize) => {
					ctx.clearRect(0, 0, width * cellSize, height * cellSize);
					for(let i = 0; i <= width; i++) {
						ctx.beginPath();
						ctx.moveTo(i * cellSize, 0);
						ctx.lineTo(i * cellSize, height * cellSize);
						ctx.stroke();
					}
					for(let j = 0; j <= height; j++) {
						ctx.beginPath();
						ctx.moveTo(0, j * cellSize);
						ctx.lineTo(width * cellSize, j * cellSize);
						ctx.stroke();
					}
				}

				const drawCell = (ctx, x, y, cellSize) => {
					const padding = 2;
					const x1 = x * cellSize + padding;
					const y1 = y * cellSize + padding;
					const size = cellSize - (2 * padding);

					ctx.fillRect(x1, y1, size, size);
				}

				const view = document.getElementById('board');
				const ctx = view.getContext('2d');

				return ((ctx, population, width, height, cellSize) => {
					drawBoard(ctx, width, height, cellSize);
					population.forEach(cell => {
						drawCell(ctx, cell.x, cell.y, cellSize);
					});
					return population;
				})(ctx, state.board.population, state.board.width, state.board.height, 10);
			};

			// -- WORKAROUND --
			// Not the best solution...
			// But we don't want to render everything each times.
			switch(originator) {
				case 'startGame':
				case 'stopGame':
					renderGameController(state.gameController);
					break;
				case 'renderStatus':
					renderStatus(state.status);
					break;
				case 'renderBoard':
					renderBoard(state.board);
					break;
				default:
					renderGameController(state.gameController);
					renderStatus(state.status);
					renderBoard(state.board);
					break;
			}
		};

		// Store
		const createStore = (reducer, onDispatch, initialState) => {
			let state = initialState || { };

			const dispatch = action => {
				state = reducer(state, action);
				onDispatch(state, action.id);
			};

			return { dispatch };
		};

		const store = createStore(game, renderGame);

		// Initial rendering
		store.dispatch({ id: 'INITIAL_RENDERING' });
	</script>
</body>
</html>
